# 🧠 Mental Health Chat Architecture - Deep Dive

## Core Requirements Understanding:
- **Ephemeral Chat**: 24-hour persistence (Redis perfect for TTL)
- **Anonymous Counseling**: Students ↔ Counselors with privacy
- **Context Summarization**: LLM-powered summaries for counselor reference
- **Tight Integration**: Chat must be meaningful to MainServer context
- **Performance**: No bottlenecks through MainServer
- **Offline Support**: FCM push notifications

## 🏗️ Proposed Architecture

### Data Flow & Integration Strategy:

```
Student/Counselor → MainServer (Session Creation + Auth)
                        ↓ (Creates chat session metadata)
                   ChatService ← Session Context
                        ↓ (Direct WebSocket for real-time)
                   Student ↔ Counselor Chat
                        ↓ (Session events)
                   Redis (message queue + TTL storage)
                        ↓ (Offline user detection)
                   FCM Service (push notifications)
```

### Key Integration Points:

#### 1. **Session Lifecycle Management**
- **MainServer Role**: Creates chat sessions, validates user types (student/counselor), manages scheduling
- **ChatService Role**: Handles real-time messaging within established sessions
- **Integration**: Session metadata flows MainServer → ChatService, but messages stay in ChatService

#### 2. **Authentication & Authorization Flow**
- **MainServer**: Issues JWT with chat permissions (`role: student/counselor`, `sessionId`, `anonymousId`)
- **ChatService**: Validates JWT, extracts session context, manages real-time connections
- **No bottleneck**: After initial auth, ChatService operates independently

#### 3. **Message Queue Strategy**
```
Real-time Flow:
User A → ChatService → Redis Pub/Sub → User B (if online)
                   ↓
              Redis TTL Storage (24h)
                   ↓
         FCM Queue (if User B offline)
```

## 🔍 Deep Dive: Session Lifecycle Management

### **Session Creation & Context Flow**

#### **Phase 1: Session Initiation**
```
Student Request → MainServer `/api/chat/request-session`
                     ↓
             Validate (student role, availability)
                     ↓
          Find available counselor OR add to queue
                     ↓
    Create session metadata in MainServer database:
    {
      sessionId: "sess_12345",
      studentId: "user_789", 
      counselorId: "counselor_456",
      studentAnonymousId: "anon_student_xyz",
      createdAt: timestamp,
      status: "active",
      chatServiceUrl: "ws://chatservice:8080"
    }
                     ↓
    Push session context to Redis:
    SET chat:session:sess_12345 {
      studentAnonymousId: "anon_student_xyz",
      counselorId: "counselor_456", 
      permissions: ["send_message", "end_session"],
      createdAt: timestamp
    } EX 86400  // 24h TTL
```

#### **Phase 2: Context Handoff**
```
MainServer → Student: 
{
  sessionId: "sess_12345",
  chatToken: "jwt_with_chat_permissions",
  chatServiceUrl: "ws://chatservice:8080/sess_12345"
}

ChatService receives connection:
1. Validates JWT (shared secret with MainServer)
2. Extracts sessionId from JWT
3. Fetches session context from Redis
4. Establishes WebSocket connection
```

## 🔐 Deep Dive: Authentication & Authorization Flow

### **JWT Structure for Chat**
```javascript
// Generated by MainServer
const chatJWT = {
  userId: "user_789",
  sessionId: "sess_12345", 
  anonymousId: "anon_student_xyz",
  role: "student", // or "counselor"
  chatPermissions: ["send_message", "view_history"],
  exp: timestamp + 24*60*60, // 24h expiry
  iss: "mainserver"
}
```

### **Authentication Flow Steps**

#### **Step 1: Initial Auth Check**
```javascript
// ChatService WebSocket connection
socket.on('connection', (ws, request) => {
  const token = extractTokenFromRequest(request);
  
  // Validate JWT with shared secret
  const decoded = jwt.verify(token, SHARED_JWT_SECRET);
  
  // Extract session context
  const sessionId = decoded.sessionId;
  const userId = decoded.userId;
  const role = decoded.role;
})
```

#### **Step 2: Session Context Validation**
```javascript
// Check if session exists and is valid
const sessionData = await redis.get(`chat:session:${sessionId}`);
if (!sessionData) {
  ws.close(4001, 'Invalid session');
  return;
}

// Verify user belongs to this session
const session = JSON.parse(sessionData);
if (role === 'student' && session.studentAnonymousId !== decoded.anonymousId) {
  ws.close(4003, 'Unauthorized');
  return;
}
```

## 📨 Deep Dive: Message Queue (Redis Pub/Sub Flow)

### **Message Flow Architecture**

#### **When User Sends Message**:
```javascript
// ChatService receives message from WebSocket
socket.on('message', async (data) => {
  const message = {
    id: generateId(),
    sessionId: userSession.sessionId,
    from: userSession.anonymousId, // Not real user ID!
    content: data.content,
    timestamp: Date.now(),
    type: 'chat_message'
  };
  
  // 1. Store in Redis with TTL
  await redis.setex(
    `chat:msg:${message.id}`, 
    86400, // 24h TTL
    JSON.stringify(message)
  );
  
  // 2. Add to session message list  
  await redis.lpush(`chat:session:${sessionId}:messages`, message.id);
  await redis.expire(`chat:session:${sessionId}:messages`, 86400);
  
  // 3. Pub/Sub to session channel
  await redis.publish(`chat:session:${sessionId}`, JSON.stringify(message));
});
```

## ⏰ Redis TTL Strategy

### **Activity-Based TTL (Recommended)**
```javascript
// Extend TTL on any activity
const extendSessionTTL = async (sessionId) => {
  await redis.expire(`chat:session:${sessionId}`, 86400); // Reset to 24h
  await redis.expire(`chat:session:${sessionId}:messages`, 86400);
  
  // Update last activity
  await redis.set(`chat:session:${sessionId}:lastActivity`, Date.now());
};

// Call on every message
socket.on('message', async (data) => {
  // ... process message ...
  await extendSessionTTL(sessionId);
});
```